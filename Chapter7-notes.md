## 交易



> 交易是由外部所有帐户发起的签名消息，由以太坊网络传输，并在以太坊区块链上进行记录（挖掘）。以太坊是一个全球的单实例状态机器，交易是唯一可以让状态机“运动”，改变状态的东西。合约不会自行运行。以太坊不会在后台运行。一切都始于交易。



### 结构

> 交易是一个序列化的二进制消息，其中包含以下数据：
>
> - nonce
>
>   由始发EOA（外部所有账户）发出的序列号，用于防止消息重播。
>
> - gas price
>
>   发起人愿意支付的gas价格（以wei为单位）。
>
> - start gas
>
>   发起人愿意支付的最大gas量。
>
> - to
>
>   目标以太坊地址。
>
> - value
>
>   发送到目标地址的ether数量。
>
> - data
>
>   变长二进制数据。
>
> - v,r,s
>
>   始发EOA的ECDSA签名的三个组成部分。



### 交易gas

> gas是以太坊的燃料。gas不是ether，它是独立的虚拟货币，有相对于ether的汇率。以太坊使用gas来控制交易可以花费的资源量，因为它将在全球数千台计算机上处理。开放式（图灵完备的）计算模型需要某种形式的计量，以避免拒绝服务攻击或无意中的资源吞噬交易。
>
> gas与ether分离，以保护系统免受随着ether价值快速变化而产生的波动。
>
> 交易中的 gasPrice 字段允许交易创建者设置每个单位的gas的汇率。

### 交易的价值和数据

> 交易的主要“负载”包含在两个字段中：value 和 data。交易可以同时具有value和data，只有value，只有data，或没有value和data。所有四种组合都是有效的。
>
> 只有value的交易是 *支付* *payment*。只有data的交易是 *调用* *invocation*。

### 将value传递给EOA和合约

> 当你构建包含 value 的以太坊交易时，它等同于_payment_。根据目的地址是否为合约，这些交易行为会有所不同。
>
> 对于EOA地址，或者更确切地说，对于未在区块链中注册为合约的任何地址，以太坊将记录状态更改，并将你发送的value添加到地址的余额中。如果地址之前没有被查看过，则会创建地址并将其余额初始化为你的付款+value+。
>
> 如果目标地址（to）是合约，则EVM将执行合约并尝试调用你的交易的 data 中指定的函数（参见 [[invocation\]](https://github.com/inoutcode/ethereum_book/blob/master/第七章.asciidoc#invocation) ）。如果你的交易中没有 data，那么EVM将调用目标合约的 *fallback* 函数，如果该函数是payable，则将执行该函数以确定下一步该做什么。
>
> 合约可以通过在调用付款功能时立即抛出异常或由付款功能中编码的条件确定来拒绝收款。如果付款功能成功终止（没有意外），则更新合约状态以反映合约的ether余额增加。

### 将数据传输到EOA或合约

> 当你的交易包含+data+时，它很可能是发送到合约地址的。这并不意味着你无法向EOA发送+data+。事实上，你可以做到这一点。但是，在这种情况下，data+的解释取决于你用来访问EOA的钱包。大多数钱包会忽略它们控制的EOA交易中收到的任何+data。将来，可能会出现允许钱包以合约的方式解释+data+编码的标准，从而允许交易调用在用户钱包内运行的函数。关键的区别在于，与合约执行不同，EOA对data的任何解释都不受以太坊共识规则的约束。
>
> 现在，假设你的交易是向合约地址提供 data。在这种情况下，data 将被EVM解释为 *函数调用* *function invocation*，调用指定的函数并将任何编码参数传递给该函数。
>
> 发送到合约的 data 是一个十六进制序列化的编码：
>
> - 函数选择器（function selector）
>
>   函数_prototype_的Keccak256哈希的前4个字节。这使EVM能够明确地识别你希望调用的功能。
>
> - 函数参数
>
>   函数的参数，根据EVM定义的各种基本类型的规则进行编码。